//===-- SPEXISelLowering.cpp - SPEX DAG lowering --*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "SPEXISelLowering.h"
#include "SPEX.h"
#include "SPEXSubtarget.h"
#include "SPEXTargetMachine.h"
#include "llvm/ADT/APInt.h"
#include "llvm/CodeGen/CallingConvLower.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/SelectionDAGNodes.h"
#include "llvm/Support/ErrorHandling.h"

using namespace llvm;

// Calling convention helpers generated by TableGen.
#include "SPEXCallingConv.inc"

SPEXTargetLowering::SPEXTargetLowering(const SPEXTargetMachine &TM,
                                       const SPEXSubtarget &ST)
    : TargetLowering(TM, ST), ST(ST) {
  addRegisterClass(MVT::i64, &SPEX::GPRRegClass);
  addRegisterClass(MVT::i32, &SPEX::GPRRegClass);
  addRegisterClass(MVT::i16, &SPEX::GPRRegClass);
  addRegisterClass(MVT::i8, &SPEX::GPRRegClass);

  computeRegisterProperties(ST.getRegisterInfo());

  setOperationAction(ISD::Constant, MVT::i1, Promote);

  setOperationAction(ISD::ZERO_EXTEND, MVT::i8, Custom);
  setOperationAction(ISD::ZERO_EXTEND, MVT::i16, Custom);
  setOperationAction(ISD::ZERO_EXTEND, MVT::i32, Custom);
  setOperationAction(ISD::ZERO_EXTEND, MVT::i64, Custom);

  setOperationAction(ISD::SIGN_EXTEND, MVT::i8, Expand);
  setOperationAction(ISD::SIGN_EXTEND, MVT::i16, Expand);
  setOperationAction(ISD::SIGN_EXTEND, MVT::i32, Custom);
  setOperationAction(ISD::SIGN_EXTEND, MVT::i64, Custom);

  setOperationAction(ISD::ANY_EXTEND, MVT::i8, Custom);
  setOperationAction(ISD::ANY_EXTEND, MVT::i16, Custom);
  setOperationAction(ISD::ANY_EXTEND, MVT::i32, Custom);
  setOperationAction(ISD::ANY_EXTEND, MVT::i64, Custom);

  setOperationAction(ISD::BR, MVT::Other, Custom);
  setOperationAction(ISD::BRCOND, MVT::Other, Custom);
  setOperationAction(ISD::BR_CC, MVT::Other, Custom);

  setOperationAction(ISD::SHL, MVT::i32, Custom);
  setOperationAction(ISD::SHL, MVT::i64, Custom);

  setOperationAction(ISD::SRL, MVT::i32, Custom);
  setOperationAction(ISD::SRL, MVT::i64, Custom);

  setOperationAction(ISD::SRA, MVT::i32, Custom);
  setOperationAction(ISD::SRA, MVT::i64, Custom);

  setOperationAction(ISD::AND, MVT::i8, Legal);
  setOperationAction(ISD::AND, MVT::i16, Legal);
  setOperationAction(ISD::AND, MVT::i32, Legal);
  setOperationAction(ISD::AND, MVT::i64, Legal);

  setOperationAction(ISD::OR, MVT::i8, Legal);
  setOperationAction(ISD::OR, MVT::i16, Legal);
  setOperationAction(ISD::OR, MVT::i32, Legal);
  setOperationAction(ISD::OR, MVT::i64, Legal);

  setOperationAction(ISD::XOR, MVT::i8, Legal);
  setOperationAction(ISD::XOR, MVT::i16, Legal);
  setOperationAction(ISD::XOR, MVT::i32, Legal);
  setOperationAction(ISD::XOR, MVT::i64, Legal);

  setOperationAction(ISD::FrameIndex, MVT::i64, Custom);

  setOperationAction(ISD::SETCC, MVT::i8, Custom);
  setOperationAction(ISD::SETCC, MVT::i16, Custom);
  setOperationAction(ISD::SETCC, MVT::i32, Custom);
  setOperationAction(ISD::SETCC, MVT::i64, Custom);

  setOperationAction(ISD::SELECT_CC, MVT::i8, Custom);
  setOperationAction(ISD::SELECT_CC, MVT::i16, Custom);
  setOperationAction(ISD::SELECT_CC, MVT::i32, Custom);
  setOperationAction(ISD::SELECT_CC, MVT::i64, Custom);

  setOperationAction(ISD::SELECT, MVT::i8, Custom);
  setOperationAction(ISD::SELECT, MVT::i16, Custom);
  setOperationAction(ISD::SELECT, MVT::i32, Custom);
  setOperationAction(ISD::SELECT, MVT::i64, Custom);

  setOperationAction(ISD::SETCC, MVT::i1, Promote);
  setOperationAction(ISD::SELECT, MVT::i1, Promote);
  setOperationAction(ISD::SELECT_CC, MVT::i1, Promote);

  setOperationAction(ISD::XOR, MVT::i1, Promote);
  setOperationAction(ISD::AND, MVT::i1, Promote);
  setOperationAction(ISD::OR, MVT::i1, Promote);
  setOperationAction(ISD::ANY_EXTEND, MVT::i1, Promote);
  setOperationAction(ISD::ZERO_EXTEND, MVT::i1, Promote);
  setOperationAction(ISD::SIGN_EXTEND, MVT::i1, Promote);
  setOperationAction(ISD::TRUNCATE, MVT::i1, Expand);

  setBooleanContents(ZeroOrOneBooleanContent);

  setTruncStoreAction(MVT::i64, MVT::i32, Expand);
  setTruncStoreAction(MVT::i64, MVT::i16, Expand);
  setTruncStoreAction(MVT::i64, MVT::i8, Expand);
  setTruncStoreAction(MVT::i32, MVT::i16, Expand);
  setTruncStoreAction(MVT::i32, MVT::i8, Expand);
  setTruncStoreAction(MVT::i16, MVT::i8, Expand);

  setLoadExtAction(ISD::ZEXTLOAD, MVT::i64, MVT::i8, Legal);
  setLoadExtAction(ISD::ZEXTLOAD, MVT::i64, MVT::i16, Legal);
  setLoadExtAction(ISD::ZEXTLOAD, MVT::i64, MVT::i32, Legal);
  setLoadExtAction(ISD::ZEXTLOAD, MVT::i32, MVT::i8, Legal);
  setLoadExtAction(ISD::ZEXTLOAD, MVT::i32, MVT::i16, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i64, MVT::i8, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i64, MVT::i16, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i64, MVT::i32, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i32, MVT::i8, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i32, MVT::i16, Legal);
  setLoadExtAction(ISD::EXTLOAD, MVT::i16, MVT::i8, Legal);

  setLoadExtAction(ISD::SEXTLOAD, MVT::i64, MVT::i8, Legal);
  setLoadExtAction(ISD::SEXTLOAD, MVT::i64, MVT::i16, Legal);
  setLoadExtAction(ISD::SEXTLOAD, MVT::i64, MVT::i32, Legal);
  setLoadExtAction(ISD::SEXTLOAD, MVT::i32, MVT::i8, Legal);
  setLoadExtAction(ISD::SEXTLOAD, MVT::i32, MVT::i16, Legal);
  setLoadExtAction(ISD::SEXTLOAD, MVT::i16, MVT::i8, Legal);

  setOperationAction(ISD::GlobalAddress, MVT::i64, Legal);
  setOperationAction(ISD::ExternalSymbol, MVT::i64, Legal);
  setOperationAction(ISD::ConstantPool, MVT::i64, Legal);
}

static unsigned getMovToRXOpc(EVT VT) {
  if (VT == MVT::i8)
    return SPEX::MOVMOV8_R;
  if (VT == MVT::i16)
    return SPEX::MOVMOV16_R;
  if (VT == MVT::i32)
    return SPEX::MOVMOV32_R;
  return SPEX::MOVMOV64_R;
}

static unsigned getMovFromRXOpc(EVT VT) {
  if (VT == MVT::i8)
    return SPEX::MOVMOV8;
  if (VT == MVT::i16)
    return SPEX::MOVMOV16;
  if (VT == MVT::i32)
    return SPEX::MOVMOV32;
  return SPEX::MOVMOV64;
}

static unsigned getCmpOpc(EVT VT) {
  if (VT == MVT::i8)
    return SPEX::CMP8_R;
  if (VT == MVT::i16)
    return SPEX::CMP16_R;
  if (VT == MVT::i32)
    return SPEX::CMP32_R;
  return SPEX::CMP64_R;
}

static unsigned getPseudoLIOpc(EVT VT) {
  if (VT == MVT::i8)
    return SPEX::PSEUDO_LI8;
  if (VT == MVT::i16)
    return SPEX::PSEUDO_LI16;
  if (VT == MVT::i32)
    return SPEX::PSEUDO_LI32;
  return SPEX::PSEUDO_LI64;
}

static unsigned getBccOpc64(ISD::CondCode CC) {
  switch (CC) {
  case ISD::SETEQ:
    return SPEX::BCC_eq_I64;
  case ISD::SETNE:
    return SPEX::BCC_ne_I64;

  case ISD::SETLT:
    return SPEX::BCC_lt_I64;
  case ISD::SETLE:
    return SPEX::BCC_le_I64;
  case ISD::SETGT:
    return SPEX::BCC_gt_I64;
  case ISD::SETGE:
    return SPEX::BCC_ge_I64;

  case ISD::SETULT:
    return SPEX::BCC_ltu_I64;
  case ISD::SETULE:
    return SPEX::BCC_leu_I64;
  case ISD::SETUGT:
    return SPEX::BCC_leu_I64;
  case ISD::SETUGE:
    return SPEX::BCC_geu_I64;

  default:
    return SPEX::BCC_ne_I64; // Conservative fallback
  }
}

static void emitCopyViaRX(MachineBasicBlock &MBB,
                          MachineBasicBlock::iterator InsertPt,
                          const DebugLoc &DL, const TargetInstrInfo &TII,
                          EVT VT, Register Dst, Register Src) {
  BuildMI(MBB, InsertPt, DL, TII.get(getMovToRXOpc(VT))).addReg(Src);
  BuildMI(MBB, InsertPt, DL, TII.get(getMovFromRXOpc(VT)), Dst);
}

MachineBasicBlock *
SPEXTargetLowering::EmitInstrWithCustomInserter(MachineInstr &MI,
                                                MachineBasicBlock *MBB) const {

  const DebugLoc &DL = MI.getDebugLoc();
  MachineFunction *MF = MBB->getParent();
  const TargetInstrInfo &TII = *ST.getInstrInfo();

  auto makeBlockAfter = [&](MachineBasicBlock *Before) -> MachineBasicBlock * {
    MachineBasicBlock *NewMBB =
        MF->CreateMachineBasicBlock(Before->getBasicBlock());
    MF->insert(std::next(Before->getIterator()), NewMBB);
    return NewMBB;
  };

  auto splitTail = [&]() -> MachineBasicBlock * {
    return MBB->splitAt(MI, true);
  };

  auto addSucc = [&](MachineBasicBlock *From, MachineBasicBlock *To) {
    if (!From->isSuccessor(To))
      From->addSuccessor(To);
  };

  switch (MI.getOpcode()) {
  case SPEX::PSEUDO_SETCC8:
  case SPEX::PSEUDO_SETCC16:
  case SPEX::PSEUDO_SETCC32:
  case SPEX::PSEUDO_SETCC64: {
    EVT VT = (MI.getOpcode() == SPEX::PSEUDO_SETCC8)    ? MVT::i8
             : (MI.getOpcode() == SPEX::PSEUDO_SETCC16) ? MVT::i16
             : (MI.getOpcode() == SPEX::PSEUDO_SETCC32) ? MVT::i32
                                                        : MVT::i64;

    Register Dst = MI.getOperand(0).getReg();
    Register LHS = MI.getOperand(1).getReg();
    Register RHS = MI.getOperand(2).getReg();
    ISD::CondCode CC = (ISD::CondCode)MI.getOperand(3).getImm();

    MachineBasicBlock *TailMBB = splitTail();
    MachineBasicBlock *SetMBB = makeBlockAfter(MBB);

    addSucc(MBB, SetMBB);
    addSucc(MBB, TailMBB);
    addSucc(SetMBB, TailMBB);

    auto InsertPt = MBB->end();

    // dst = 0
    BuildMI(*MBB, InsertPt, DL, TII.get(getPseudoLIOpc(VT)), Dst).addImm(0);

    // Compare: RX <- LHS; CMP rhs
    BuildMI(*MBB, InsertPt, DL, TII.get(getMovToRXOpc(VT))).addReg(LHS);
    BuildMI(*MBB, InsertPt, DL, TII.get(getCmpOpc(VT))).addReg(RHS);

    // if (CC) goto SetMBB
    BuildMI(*MBB, InsertPt, DL, TII.get(getBccOpc64(CC))).addMBB(SetMBB);

    // goto Tail
    BuildMI(*MBB, InsertPt, DL, TII.get(SPEX::JMP)).addMBB(TailMBB);

    // SetMBB: dst = 1; goto Tail
    auto SetIP = SetMBB->end();
    BuildMI(*SetMBB, SetIP, DL, TII.get(getPseudoLIOpc(VT)), Dst).addImm(1);
    BuildMI(*SetMBB, SetIP, DL, TII.get(SPEX::JMP)).addMBB(TailMBB);

    MI.eraseFromParent();
    return TailMBB;
  }
  case SPEX::PSEUDO_SELECT8:
  case SPEX::PSEUDO_SELECT16:
  case SPEX::PSEUDO_SELECT32:
  case SPEX::PSEUDO_SELECT64: {
    EVT VT = (MI.getOpcode() == SPEX::PSEUDO_SELECT8)    ? MVT::i8
             : (MI.getOpcode() == SPEX::PSEUDO_SELECT16) ? MVT::i16
             : (MI.getOpcode() == SPEX::PSEUDO_SELECT32) ? MVT::i32
                                                         : MVT::i64;

    Register Dst = MI.getOperand(0).getReg();
    Register Cond = MI.getOperand(1).getReg();
    Register TVal = MI.getOperand(2).getReg();
    Register FVal = MI.getOperand(3).getReg();

    MachineBasicBlock *TailMBB = splitTail();
    MachineBasicBlock *TrueMBB = makeBlockAfter(MBB);

    addSucc(MBB, TrueMBB);
    addSucc(MBB, TailMBB);
    addSucc(TrueMBB, TailMBB);

    auto InsertPt = MBB->end();

    // Use Dst as temporary zero for (Cond != 0) compare
    BuildMI(*MBB, InsertPt, DL, TII.get(getPseudoLIOpc(VT)), Dst).addImm(0);
    BuildMI(*MBB, InsertPt, DL, TII.get(getMovToRXOpc(VT))).addReg(Cond);
    BuildMI(*MBB, InsertPt, DL, TII.get(getCmpOpc(VT))).addReg(Dst);

    // If Cond != 0 -> TrueMBB
    BuildMI(*MBB, InsertPt, DL, TII.get(SPEX::BCC_ne_I64)).addMBB(TrueMBB);

    // False path: dst = fval; goto Tail
    emitCopyViaRX(*MBB, InsertPt, DL, TII, VT, Dst, FVal);
    BuildMI(*MBB, InsertPt, DL, TII.get(SPEX::JMP)).addMBB(TailMBB);

    // TrueMBB: dst = tval; goto Tail
    auto TrueIP = TrueMBB->end();
    emitCopyViaRX(*TrueMBB, TrueIP, DL, TII, VT, Dst, TVal);
    BuildMI(*TrueMBB, TrueIP, DL, TII.get(SPEX::JMP)).addMBB(TailMBB);

    MI.eraseFromParent();
    return TailMBB;
  }
  // dst = (lhs CC rhs) ? tval : fval
  case SPEX::PSEUDO_SELECT_CC8:
  case SPEX::PSEUDO_SELECT_CC16:
  case SPEX::PSEUDO_SELECT_CC32:
  case SPEX::PSEUDO_SELECT_CC64: {
    EVT VT = (MI.getOpcode() == SPEX::PSEUDO_SELECT_CC8)    ? MVT::i8
             : (MI.getOpcode() == SPEX::PSEUDO_SELECT_CC16) ? MVT::i16
             : (MI.getOpcode() == SPEX::PSEUDO_SELECT_CC32) ? MVT::i32
                                                            : MVT::i64;

    Register Dst = MI.getOperand(0).getReg();
    Register LHS = MI.getOperand(1).getReg();
    Register RHS = MI.getOperand(2).getReg();
    Register TVal = MI.getOperand(3).getReg();
    Register FVal = MI.getOperand(4).getReg();
    ISD::CondCode CC = (ISD::CondCode)MI.getOperand(5).getImm();

    MachineBasicBlock *TailMBB = splitTail();
    MachineBasicBlock *TrueMBB = makeBlockAfter(MBB);

    addSucc(MBB, TrueMBB);
    addSucc(MBB, TailMBB);
    addSucc(TrueMBB, TailMBB);

    auto InsertPt = MBB->end();

    // Compare: RX <- LHS; CMP rhs
    BuildMI(*MBB, InsertPt, DL, TII.get(getMovToRXOpc(VT))).addReg(LHS);
    BuildMI(*MBB, InsertPt, DL, TII.get(getCmpOpc(VT))).addReg(RHS);

    // If (CC) -> TrueMBB
    BuildMI(*MBB, InsertPt, DL, TII.get(getBccOpc64(CC))).addMBB(TrueMBB);

    // False path: dst = fval; goto Tail
    emitCopyViaRX(*MBB, InsertPt, DL, TII, VT, Dst, FVal);
    BuildMI(*MBB, InsertPt, DL, TII.get(SPEX::JMP)).addMBB(TailMBB);

    // TrueMBB: dst = tval; goto Tail
    auto TrueIP = TrueMBB->end();
    emitCopyViaRX(*TrueMBB, TrueIP, DL, TII, VT, Dst, TVal);
    BuildMI(*TrueMBB, TrueIP, DL, TII.get(SPEX::JMP)).addMBB(TailMBB);

    MI.eraseFromParent();
    return TailMBB;
  }
  default:
    return MBB;
  }
}

SPEXTargetLowering::LegalizeKind
SPEXTargetLowering::getTypeConversion(LLVMContext &ctx, EVT VT) {
  if (VT == MVT::i1) {
    return LegalizeKind(TargetLoweringBase::TypePromoteInteger, MVT::i8);
  }
  return this->TargetLowering::getTypeConversion(ctx, VT);
}

EVT SPEXTargetLowering::getTypeToTransformTo(LLVMContext &ctx, EVT VT) const {
  if (VT == MVT::i1) {
    return MVT::i8;
  }
  return this->TargetLowering::getTypeToTransformTo(ctx, VT);
}

const char *SPEXTargetLowering::getTargetNodeName(unsigned Opcode) const {
  switch (Opcode) {
  case SPEXISD::CALL:
    return "SPEXISD::CALL";
  case SPEXISD::RET:
    return "SPEXISD::RET";
  case SPEXISD::LSTOP:
    return "SPEXISD::LSTOP";
  case SPEXISD::LWAIT:
    return "SPEXISD::LWAIT";
  case SPEXISD::LWAKE:
    return "SPEXISD::LWAKE";
  default:
    return nullptr;
  }
}

static SDValue emitRXMoveWithOptionalClearValue(SelectionDAG &DAG,
                                                const SDLoc &DL, EVT DstVT,
                                                SDValue Src, unsigned SrcBits,
                                                bool ClearHighBitsWithZero) {
  // ---- choose mov opcode ----
  unsigned MovOpc = 0;
  switch (SrcBits) {
  case 1:
  case 8:
    MovOpc = SPEX::MOVMOV8_R;
    break;
  case 16:
    MovOpc = SPEX::MOVMOV16_R;
    break;
  case 32:
    MovOpc = SPEX::MOVMOV32_R;
    break;
  case 64:
    MovOpc = SPEX::MOVMOV64_R;
    break;
  default:
    llvm_unreachable("bad extend size");
  }

  // ---- RX = mov ----
  SDNode *MovN;
  MovN = DAG.getMachineNode(MovOpc, DL, MVT::Glue, Src);

  SDValue Glue(MovN, 0);

  // ---- read RX value ----
  SDValue Chain = DAG.getEntryNode();
  SDValue Val = DAG.getCopyFromReg(Chain, DL, SPEX::RX, DstVT, Glue);

  return Val;
}

SDValue SPEXTargetLowering::LowerOperation(SDValue Op,
                                           SelectionDAG &DAG) const {
  switch (Op.getOpcode()) {
  case ISD::FrameIndex: {
    // Legalize raw FrameIndex nodes into target-specific frame indices so they
    // can be used as operands and later resolved by eliminateFrameIndex.
    auto *FI = cast<FrameIndexSDNode>(Op.getNode());
    return DAG.getTargetFrameIndex(FI->getIndex(), MVT::i64);
  }
  case ISD::BRCOND:
    return LowerBRCOND(Op, DAG);
  case ISD::SHL:
    return LowerShift(Op, DAG, SPEXISD::SHL_I);
  case ISD::SRL:
    return LowerShift(Op, DAG, SPEXISD::SRL_I);
  case ISD::SRA:
    return LowerShift(Op, DAG, SPEXISD::SRA_I);
  case ISD::SIGN_EXTEND: {
    SDValue Src = Op.getOperand(0);
    EVT DstVT = Op.getValueType();
    EVT SrcVT = Src.getValueType();

    if (!(DstVT == MVT::i32 || DstVT == MVT::i64))
      break;
    unsigned DstBits = DstVT.getSizeInBits();
    unsigned SrcBits = SrcVT.getSizeInBits();

    if (!(SrcBits == 8 || SrcBits == 16 || SrcBits == 32) || SrcBits >= DstBits)
      break;

    SDLoc DL(Op);

    SDValue Wide = DAG.getNode(ISD::ZERO_EXTEND, DL, DstVT, Src);

    SDValue InVT = DAG.getValueType(SrcVT);
    return DAG.getNode(ISD::SIGN_EXTEND_INREG, DL, DstVT, Wide, InVT);
  }

  case ISD::GlobalAddress: {
    auto *GA = cast<GlobalAddressSDNode>(Op);
    return DAG.getTargetGlobalAddress(GA->getGlobal(), SDLoc(Op),
                                      Op.getValueType(), GA->getOffset());
  }

  case ISD::ExternalSymbol: {
    auto *ES = cast<ExternalSymbolSDNode>(Op);
    return DAG.getTargetExternalSymbol(ES->getSymbol(), Op.getValueType(),
                                       ES->getTargetFlags());
  }

  case ISD::ConstantPool: {
    auto *CP = cast<ConstantPoolSDNode>(Op);
    return DAG.getTargetConstantPool(CP->getConstVal(), Op.getValueType(),
                                     CP->getAlign(), CP->getOffset());
  }

  case ISD::ZERO_EXTEND: {
    SDLoc DL(Op);
    SDValue Src = Op.getOperand(0);
    EVT SrcVT = Src.getValueType();
    EVT DstVT = Op.getValueType();

    if (!DstVT.isSimple() || !SrcVT.isSimple())
      break;

    unsigned SrcBits = SrcVT.getSizeInBits();
    unsigned DstBits = DstVT.getSizeInBits();

    if (SrcBits >= DstBits)
      return Src;

    if (!(SrcBits == 1 || SrcBits == 8 || SrcBits == 16 || SrcBits == 32))
      break;
    if (!(DstBits == 16 || DstBits == 32 || DstBits == 64))
      break;

    return emitRXMoveWithOptionalClearValue(DAG, DL, DstVT, Src, SrcBits, true);
  }
  case ISD::ANY_EXTEND: {
    SDLoc DL(Op);
    SDValue Src = Op->getOperand(0);
    EVT SrcVT = Src.getValueType();
    EVT DstVT = Op.getValueType();

    if (!DstVT.isSimple() || !SrcVT.isSimple())
      break;

    unsigned SrcBits = SrcVT.getSizeInBits();
    unsigned DstBits = DstVT.getSizeInBits();

    if (SrcBits == DstBits)
      return Src;
    if (SrcBits > DstBits)
      return DAG.getNode(ISD::TRUNCATE, DL, DstVT, Src);

    if (!(SrcBits == 1 || SrcBits == 8 || SrcBits == 16 || SrcBits == 32))
      break;
    if (!(DstBits == 16 || DstBits == 32 || DstBits == 64))
      break;

    return emitRXMoveWithOptionalClearValue(DAG, DL, DstVT, Src, SrcBits,
                                            false);
  }
  case ISD::SETCC:
    return LowerSETCC(Op, DAG);
  case ISD::SELECT:
    return LowerSELECT(Op, DAG);
  case ISD::SELECT_CC:
    return LowerSELECT_CC(Op, DAG);
  default:
    break;
  }
  return SDValue();
}

SDValue SPEXTargetLowering::LowerFormalArguments(
    SDValue Chain, CallingConv::ID CallConv, bool IsVarArg,
    const SmallVectorImpl<ISD::InputArg> &Ins, const SDLoc &DL,
    SelectionDAG &DAG, SmallVectorImpl<SDValue> &InVals) const {
  if (CallConv != CallingConv::C && CallConv != CallingConv::Fast)
    report_fatal_error("SPEX: unsupported calling convention");
  if (IsVarArg)
    report_fatal_error("SPEX: variadic arguments not supported");

  MachineFunction &MF = DAG.getMachineFunction();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  SmallVector<CCValAssign, 16> ArgLocs;
  CCState CCInfo(CallConv, IsVarArg, MF, ArgLocs, *DAG.getContext());
  CCInfo.AnalyzeFormalArguments(Ins, CC_SPEX);

  for (const CCValAssign &VA : ArgLocs) {
    EVT RegVT = VA.getLocVT();

    if (VA.isRegLoc()) {
      Register VReg = MRI.createVirtualRegister(&SPEX::GPRRegClass);
      MRI.addLiveIn(VA.getLocReg(), VReg);
      SDValue ArgValue = DAG.getCopyFromReg(Chain, DL, VReg, RegVT);

      if (VA.getLocInfo() == CCValAssign::SExt)
        ArgValue = DAG.getNode(ISD::AssertSext, DL, RegVT, ArgValue,
                               DAG.getValueType(VA.getValVT()));
      else if (VA.getLocInfo() == CCValAssign::ZExt)
        ArgValue = DAG.getNode(ISD::AssertZext, DL, RegVT, ArgValue,
                               DAG.getValueType(VA.getValVT()));

      if (VA.getLocInfo() != CCValAssign::Full || RegVT != VA.getValVT())
        ArgValue = DAG.getNode(ISD::TRUNCATE, DL, VA.getValVT(), ArgValue);

      InVals.push_back(ArgValue);
      continue;
    }

    // Stack-passed argument: load from [SP + locmemoffset] at function entry.
    MachineFrameInfo &MFI = MF.getFrameInfo();
    int FI = MFI.CreateFixedObject(/*Size=*/8, VA.getLocMemOffset(),
                                   /*IsImmutable=*/true);
    SDValue FIN = DAG.getFrameIndex(FI, MVT::i64);
    SDValue Ld = DAG.getLoad(RegVT, DL, Chain, FIN,
                             MachinePointerInfo::getFixedStack(MF, FI));
    InVals.push_back(Ld);
    Chain = Ld.getValue(1);
  }

  return Chain;
}

SDValue
SPEXTargetLowering::LowerReturn(SDValue Chain, CallingConv::ID CallConv,
                                bool IsVarArg,
                                const SmallVectorImpl<ISD::OutputArg> &Outs,
                                const SmallVectorImpl<SDValue> &OutVals,
                                const SDLoc &DL, SelectionDAG &DAG) const {

  if (Outs.size() > 1)
    report_fatal_error("SPEX: only one return value is supported");

  SmallVector<CCValAssign, 4> RetLocs;
  CCState CCInfo(CallConv, IsVarArg, DAG.getMachineFunction(), RetLocs,
                 *DAG.getContext());
  CCInfo.AnalyzeReturn(Outs, RetCC_SPEX);

  SDValue Glue;

  if (!OutVals.empty()) {
    SDValue RV = OutVals[0];
    const CCValAssign &VA = RetLocs[0];

    EVT LocVT = VA.getLocVT();
    EVT ValVT = VA.getValVT();

    if (RV.getValueType() != ValVT)
      RV = DAG.getNode(ISD::BITCAST, DL, ValVT, RV);

    switch (VA.getLocInfo()) {
    case CCValAssign::SExt:
      RV = DAG.getNode(ISD::SIGN_EXTEND, DL, LocVT, RV);
      break;
    case CCValAssign::ZExt:
      RV = DAG.getNode(ISD::ZERO_EXTEND, DL, LocVT, RV);
      break;
    case CCValAssign::AExt:
      RV = DAG.getNode(ISD::ANY_EXTEND, DL, LocVT, RV);
      break;
    case CCValAssign::Full:
      if (RV.getValueType() != LocVT)
        RV = DAG.getNode(ISD::BITCAST, DL, LocVT, RV);
      break;
    default:
      llvm_unreachable("SPEX: unknown return locinfo");
    }

    Chain = DAG.getCopyToReg(Chain, DL, VA.getLocReg(), RV, Glue);
    Glue = Chain.getValue(1);

    return DAG.getNode(SPEXISD::RET, DL, MVT::Other, Chain, Glue);
  }

  return DAG.getNode(SPEXISD::RET, DL, MVT::Other, Chain);
}

SDValue SPEXTargetLowering::LowerShift(SDValue Op, SelectionDAG &DAG,
                                       unsigned TgtOpc) const {
  SDLoc DL(Op);
  EVT VT = Op.getValueType();

  // We only custom-lower constant shift amounts. Non-constant shifts can
  // be expanded or legalized later.
  auto *C = dyn_cast<ConstantSDNode>(Op.getOperand(1));
  if (!C)
    return SDValue();

  uint64_t Amt = C->getZExtValue();
  // LLVM IR/SelectionDAG allows overshifts; keep behavior well-defined by
  // masking to element size (like many ISAs) or let it be expanded.
  unsigned Bits = VT.getSizeInBits();
  if (Bits == 0)
    return SDValue();
  Amt &= (Bits - 1);

  SDValue Imm = DAG.getConstant(Amt, DL, MVT::i32);
  return DAG.getNode(TgtOpc, DL, VT, Op.getOperand(0), Imm);
}

SDValue SPEXTargetLowering::LowerBRCOND(SDValue Op, SelectionDAG &DAG) const {
  SDLoc DL(Op);
  auto *N = cast<SDNode>(Op);

  SDValue Chain = N->getOperand(0);
  SDValue Cond = N->getOperand(1);
  SDValue Dest = N->getOperand(2);

  if (Cond.getOpcode() == ISD::SETCC) {
    SDValue LHS = Cond.getOperand(0);
    SDValue RHS = Cond.getOperand(1);
    auto CC = cast<CondCodeSDNode>(Cond.getOperand(2))->get();
    SDValue CCV = DAG.getCondCode(CC);

    return DAG.getNode(ISD::BR_CC, DL, MVT::Other, Chain, CCV, LHS, RHS, Dest);
  }

  SDValue Zero = DAG.getConstant(0, DL, Cond.getValueType());

  return DAG.getNode(ISD::BR_CC, DL, MVT::Other, Chain,
                     DAG.getCondCode(ISD::SETNE), Cond, Zero, Dest);
}

SDValue SPEXTargetLowering::LowerSETCC(SDValue Op, SelectionDAG &DAG) const {
  SDLoc DL(Op);
  EVT VT = Op.getValueType();

  SDValue LHS = Op.getOperand(0);
  SDValue RHS = Op.getOperand(1);
  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(2))->get();
  SDValue CCImm = DAG.getConstant((int)CC, DL, MVT::i32);

  unsigned Opc = 0;
  if (VT == MVT::i8)
    Opc = SPEX::PSEUDO_SETCC8;
  else if (VT == MVT::i16)
    Opc = SPEX::PSEUDO_SETCC16;
  else if (VT == MVT::i32)
    Opc = SPEX::PSEUDO_SETCC32;
  else if (VT == MVT::i64)
    Opc = SPEX::PSEUDO_SETCC64;
  else
    return SDValue(); // Unexpected type

  return SDValue(DAG.getMachineNode(Opc, DL, VT, {LHS, RHS, CCImm}), 0);
}

SDValue SPEXTargetLowering::LowerSELECT(SDValue Op, SelectionDAG &DAG) const {
  SDLoc DL(Op);
  EVT VT = Op.getValueType();

  SDValue Cond = Op.getOperand(0);
  SDValue TVal = Op.getOperand(1);
  SDValue FVal = Op.getOperand(2);

  unsigned Opc = 0;
  if (VT == MVT::i8)
    Opc = SPEX::PSEUDO_SELECT8;
  else if (VT == MVT::i16)
    Opc = SPEX::PSEUDO_SELECT16;
  else if (VT == MVT::i32)
    Opc = SPEX::PSEUDO_SELECT32;
  else if (VT == MVT::i64)
    Opc = SPEX::PSEUDO_SELECT64;
  else
    return SDValue();

  return SDValue(DAG.getMachineNode(Opc, DL, VT, {Cond, TVal, FVal}), 0);
}

SDValue SPEXTargetLowering::LowerSELECT_CC(SDValue Op,
                                           SelectionDAG &DAG) const {
  SDLoc DL(Op);
  EVT VT = Op.getValueType();

  SDValue LHS = Op.getOperand(0);
  SDValue RHS = Op.getOperand(1);
  SDValue TVal = Op.getOperand(2);
  SDValue FVal = Op.getOperand(3);
  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(4))->get();
  SDValue CCImm = DAG.getConstant((int)CC, DL, MVT::i32);

  unsigned Opc = 0;
  if (VT == MVT::i8)
    Opc = SPEX::PSEUDO_SELECT_CC8;
  else if (VT == MVT::i16)
    Opc = SPEX::PSEUDO_SELECT_CC16;
  else if (VT == MVT::i32)
    Opc = SPEX::PSEUDO_SELECT_CC32;
  else if (VT == MVT::i64)
    Opc = SPEX::PSEUDO_SELECT_CC64;
  else
    return SDValue();

  return SDValue(DAG.getMachineNode(Opc, DL, VT, {LHS, RHS, TVal, FVal, CCImm}),
                 0);
}

SDValue SPEXTargetLowering::LowerCall(TargetLowering::CallLoweringInfo &CLI,
                                      SmallVectorImpl<SDValue> &InVals) const {
  SelectionDAG &DAG = CLI.DAG;
  SDLoc DL(CLI.DL);
  SDValue Chain = CLI.Chain;
  SDValue Callee = CLI.Callee;
  CallingConv::ID CallConv = CLI.CallConv;

  if (CLI.IsTailCall)
    CLI.IsTailCall = false;

  if (CallConv != CallingConv::C && CallConv != CallingConv::Fast)
    report_fatal_error("SPEX: unsupported calling convention");

  if (CLI.IsVarArg)
    report_fatal_error("SPEX: variadic arguments not supported");

  SmallVector<CCValAssign, 16> ArgLocs;
  CCState CCInfo(CallConv, CLI.IsVarArg, DAG.getMachineFunction(), ArgLocs,
                 *DAG.getContext());
  CCInfo.AnalyzeCallOperands(CLI.Outs, CC_SPEX);

  unsigned NumBytes = CCInfo.getStackSize();
  Chain = DAG.getCALLSEQ_START(Chain, NumBytes, 0, DL);

  SmallVector<std::pair<unsigned, SDValue>, 4> RegsToPass;
  for (unsigned I = 0, E = ArgLocs.size(); I != E; ++I) {
    const CCValAssign &VA = ArgLocs[I];
    SDValue Arg = CLI.OutVals[I];

    switch (VA.getLocInfo()) {
    case CCValAssign::Full:
      break;
    case CCValAssign::SExt:
      Arg = DAG.getNode(ISD::SIGN_EXTEND, DL, VA.getLocVT(), Arg);
      break;
    case CCValAssign::ZExt:
      Arg = DAG.getNode(ISD::ZERO_EXTEND, DL, VA.getLocVT(), Arg);
      break;
    case CCValAssign::AExt:
      Arg = DAG.getNode(ISD::ANY_EXTEND, DL, VA.getLocVT(), Arg);
      break;
    default:
      llvm_unreachable("SPEX: unknown argument extension");
    }

    if (VA.isRegLoc()) {
      RegsToPass.push_back({VA.getLocReg(), Arg});
      continue;
    }

    // Stack argument: store to outgoing call frame at [SP + LocMemOffset].
    SDValue SPReg = DAG.getRegister(SPEX::R63, MVT::i64);
    int64_t Off = VA.getLocMemOffset();
    SDValue Ptr = DAG.getNode(ISD::ADD, DL, MVT::i64, SPReg,
                              DAG.getConstant(Off, DL, MVT::i64));
    Chain = DAG.getStore(Chain, DL, Arg, Ptr, MachinePointerInfo());
    continue;
  }

  SDValue InGlue;
  for (const auto &RegArg : RegsToPass) {
    Chain = DAG.getCopyToReg(Chain, DL, RegArg.first, RegArg.second, InGlue);
    InGlue = Chain.getValue(1);
  }

  SDValue Target;
  switch (Callee.getOpcode()) {
  case ISD::TargetGlobalAddress:
    Target = Callee;
    break;
  case ISD::GlobalAddress: {
    auto *GA = cast<GlobalAddressSDNode>(Callee);
    Target = DAG.getTargetGlobalAddress(GA->getGlobal(), DL,
                                        getPointerTy(DAG.getDataLayout()),
                                        GA->getOffset(), GA->getTargetFlags());
    break;
  }
  case ISD::ExternalSymbol: {
    auto *ES = cast<ExternalSymbolSDNode>(Callee);
    Target = DAG.getTargetExternalSymbol(ES->getSymbol(),
                                         getPointerTy(DAG.getDataLayout()));
    break;
  }
  default:
    if (Callee.getValueType() != MVT::i64)
      Target = DAG.getNode(ISD::ZERO_EXTEND, DL, MVT::i64, Callee);
    else
      Target = Callee;
    break;
  }

  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);
  SmallVector<SDValue, 8> Ops;
  Ops.push_back(Chain);
  Ops.push_back(Target);

  const TargetRegisterInfo *TRI = ST.getRegisterInfo();
  const uint32_t *Mask =
      TRI->getCallPreservedMask(DAG.getMachineFunction(), CallConv);
  assert(Mask && "SPEX: missing call preserved mask");
  Ops.push_back(DAG.getRegisterMask(Mask));

  for (const auto &RegArg : RegsToPass)
    Ops.push_back(DAG.getRegister(RegArg.first, RegArg.second.getValueType()));

  if (InGlue.getNode())
    Ops.push_back(InGlue);

  SDValue Call = DAG.getNode(SPEXISD::CALL, DL, NodeTys, Ops);
  SDValue CallCh = Call.getValue(0);
  SDValue CallGlue = Call.getValue(1);

  SDValue End = DAG.getCALLSEQ_END(CallCh, NumBytes, 0, CallGlue, DL);

  SDValue ChainOut = End;
  SDValue GlueOut;

  if (End.getNode()->getNumValues() > 1) {
    GlueOut = End.getValue(1);
  }

  SDValue ResultChain =
      lowerCallResult(ChainOut, GlueOut, DL, CLI.Ins, DAG, InVals);
  return ResultChain;
}

SDValue SPEXTargetLowering::lowerCallResult(
    SDValue Chain, SDValue InGlue, const SDLoc &DL,
    const SmallVectorImpl<ISD::InputArg> &Ins, SelectionDAG &DAG,
    SmallVectorImpl<SDValue> &InVals) const {
  if (Ins.empty())
    return Chain;

  // We only support one return value for now.
  if (Ins.size() > 1)
    report_fatal_error("SPEX: only one return value is supported");

  SmallVector<CCValAssign, 1> RVLocs;
  CCState CCInfo(CallingConv::C, /*IsVarArg=*/false, DAG.getMachineFunction(),
                 RVLocs, *DAG.getContext());

  // Use the same return CC rule used by the callee side.
  CCInfo.AnalyzeCallResult(Ins, RetCC_SPEX);

  const CCValAssign &VA = RVLocs[0];

  // Fetch the raw value from the return register in the ABI type (usually i64).
  SDValue Val =
      DAG.getCopyFromReg(Chain, DL, VA.getLocReg(), VA.getLocVT(), InGlue);
  Chain = Val.getValue(1);
  InGlue = Val.getValue(2);

  // Convert to the requested IR type using LocInfo.
  SDValue Res = Val;

  // If the IR expects a smaller type, truncate first.
  if (VA.getValVT() != VA.getLocVT())
    Res = DAG.getNode(ISD::TRUNCATE, DL, VA.getValVT(), Res);

  switch (VA.getLocInfo()) {
  case CCValAssign::Full:
    break;
  case CCValAssign::SExt:
    // Caller-side canonicalization (rarely needed if callee already
    // sign-extends, but keeps behavior consistent under optimization).
    Res = DAG.getNode(ISD::SIGN_EXTEND, DL, VA.getValVT(), Res);
    break;
  case CCValAssign::ZExt:
    Res = DAG.getNode(ISD::ZERO_EXTEND, DL, VA.getValVT(), Res);
    break;
  case CCValAssign::AExt:
    Res = DAG.getNode(ISD::ANY_EXTEND, DL, VA.getValVT(), Res);
    break;
  default:
    llvm_unreachable("SPEX: unknown return LocInfo");
  }

  InVals.push_back(Res);
  return Chain;
}

EVT SPEXTargetLowering::getSetCCResultType(const DataLayout &DL,
                                           LLVMContext &Context, EVT VT) const {
  return MVT::i1;
}
